# 1- 堆（Heap）的核心概述

## JVM内存结构图

![](https://gitee.com/clancy/images/raw/master/img/image-20201228170309792.png)



## 概念

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。
  - 堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定，堆可以处于**物理上不连续**的内存空间中，但在**逻辑上**它应该被视为**连续**的。
- 所有的线程共享Java堆，在这里还可以划分**线程私有的缓冲区**（Thread Local Allocation Buffer， TLAB）

- 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应在运行时分配在堆上。（The heap is the run- time data area from which memory for all class instances and arrays is allocated） 
  - 我要说的是：“几乎”所有的对象实例都在这里分配内存。一从实际使用角度看的。

- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 堆，是GC（Garbage Collection），垃圾收集器)执行垃圾回收的重点区域。

## 对象运行图

![image-20210118214313343](https://gitee.com/clancy/images/raw/master/img/20210118214327.png)

## 堆的内存区域划分

![image-20210118215211253](https://gitee.com/clancy/images/raw/master/img/20210118215214.png)

## 堆内存区域查看demo

### 修改堆启动参数，运行代码。

```java
/**
 * 修改jvm的堆的初始化大小与最大的大小
 *  -Xms10m -Xmx10m
 */
public class HeapDemo {

    public static void main(String[] args) {
        System.out.println("start...");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("end...");
    }

}
```

### Java visual VM工具

打开`jvisualvm`工具，找到HeapDemo的进程打开。要想看堆内存的大小，需要安装插件。

> 工具 -> 插件 -> 设置，编辑插件中心，修改URL为`https://visualvm.github.io/archive/uc/7u60/updates.xml.gz`
>
> 然后在【可用插件】 中点击【检查最新版本】，在更新出来的插件中选择【Visual GC】

### Visual GC查看结果

> 堆默认初始值
>
> 初始堆是内存的1/64，最大堆是内存的1/4。
>
> 新生代（Eden、survivor0、survivor1）与老年代的大小比例为：1:2

![image-20210118221912126](https://gitee.com/clancy/images/raw/master/img/20210118221913.png)

## 堆的内存结构图（JDK7）

![image-20210118230544932](https://gitee.com/clancy/images/raw/master/img/20210118230546.png)

## 堆的内存结构图（JDK8）

> JDK8使用了元空间替代了永久代

![image-20210118230905767](https://gitee.com/clancy/images/raw/master/img/20210118230907.png)

## 打印JDK8 GC详情

> -Xms10m -Xmx10m -XX:+PrintGCDetails
>
> 设置初始，最大堆内存为10M并打印GC详情

JDK8

```java
[GC (Allocation Failure) [PSYoungGen: 2048K->504K(2560K)] 2048K->883K(9728K), 0.0022439 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 2560K, used 1108K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
  eden space 2048K, 29% used [0x00000000ffd00000,0x00000000ffd970e0,0x00000000fff00000)
  from space 512K, 98% used [0x00000000fff00000,0x00000000fff7e010,0x00000000fff80000)
  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
 ParOldGen       total 7168K, used 379K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
  object space 7168K, 5% used [0x00000000ff600000,0x00000000ff65ed18,0x00000000ffd00000)
 Metaspace       used 3274K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 356K, capacity 388K, committed 512K, reserved 1048576K
```



# 2- 设置堆内存大小与OOM

## 堆空间大小的设置

> [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC) 搜索java参数名

- Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项“-Xmx”和”-Xms“来进行设置。
  - “-Xms"用于表示堆区的起始内存，等价于-XX:InitialHeapSize
  - “-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize
- 一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出Outofmemoryerror异常。
- 通常会将 -Xms 和 -Xmx 两个参数配置相同的值，其**目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。**
- 默认情况下，初始内存大小：物理电脑内存大小1/64
- 最大内存大小：物理电脑内存大小1/4

## 堆内存分配代码示例

```java
package com.chaocode.jvm.atguigu.chapter08.java;

/**
 * 1. 设置堆空间大小的参数
 * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小
 *      -X 是jvm的运行参数
 *      ms 是memory start
 * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小
 *
 * 2. 默认堆空间的大小
 *    初始内存大小：物理电脑内存大小 / 64
 *             最大内存大小：物理电脑内存大小 / 4
 * 3. 手动设置：-Xms600m -Xmx600m
 *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。这样可以省掉堆内存变换大小使用掉的时间。
 *
 * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id
 *                  方式二：-XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  20:15
 */
public class HeapSpaceInitial {
    public static void main(String[] args) {

        //返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        //返回Java虚拟机试图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;

        System.out.println("-Xms : " + initialMemory + "M");
        System.out.println("-Xmx : " + maxMemory + "M");

        System.out.println("系统内存大小为：" + initialMemory * 64.0 / 1024 + "G");
        System.out.println("系统内存大小为：" + maxMemory * 4.0 / 1024 + "G");

        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 正常输出结果

```java
-Xms : 121M
-Xmx : 1787M
系统内存大小为：7.5625G
系统内存大小为：6.98046875G
```

commands 输出

```java
C:\Users\QiongchaoLi>jps
27600 Launcher
14452 HeapSpaceInitial
22132
5252 Launcher
25048 Jps
10412 org.eclipse.equinox.launcher_1.6.0.v20200915-1508.jar
25036 Launcher

C:\Users\QiongchaoLi>jstat -gc 14452
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT
5120.0 5120.0  0.0    0.0   32768.0   5252.1   86016.0      0.0     4480.0 770.2  384.0   75.9       0    0.000   0      0.000   -          -    0.000
```

> jps：查看所有的java进程
>
> jstat -gc：打印堆GC的行为统计
>
> S0C: Survivor space 0 的总大小; S0U: Survivor space 0的使用大小；EC: 指Eden区总的大小。OC: 指老年代的总大小；MC: 元空间的总大小；[see more](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHHGFAE)

### 设置JVM结果

注释掉`Thread.sleep(1000000);`

JVM参数：`-Xms600m -Xmx600m -XX:+PrintGCDetails`

```java
-Xms : 575M
-Xmx : 575M
系统内存大小为：35.9375G
系统内存大小为：2.24609375G
Heap
 PSYoungGen      total 179200K, used 12288K [0x00000000f3800000, 0x0000000100000000, 0x0000000100000000)
  eden space 153600K, 8% used [0x00000000f3800000,0x00000000f44001b8,0x00000000fce00000)
  from space 25600K, 0% used [0x00000000fe700000,0x00000000fe700000,0x0000000100000000)
  to   space 25600K, 0% used [0x00000000fce00000,0x00000000fce00000,0x00000000fe700000)
 ParOldGen       total 409600K, used 0K [0x00000000da800000, 0x00000000f3800000, 0x00000000f3800000)
  object space 409600K, 0% used [0x00000000da800000,0x00000000da800000,0x00000000f3800000)
 Metaspace       used 3314K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 360K, capacity 388K, committed 512K, reserved 1048576K
```

Command 输出

```java
C:\Users\QiongchaoLi>jps
27600 Launcher
22132
24360 HeapSpaceInitial
25592 Launcher
10412 org.eclipse.equinox.launcher_1.6.0.v20200915-1508.jar
21772 Jps
25036 Launcher

C:\Users\QiongchaoLi>jstat -gc 24360
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT
25600.0 25600.0  0.0    0.0   153600.0 12288.1   409600.0     0.0     4480.0 770.2  384.0   75.9       0    0.000   0      0.000   -          -    0.000

C:\Users\QiongchaoLi>jinfo -flags 24360
VM Flags:
-XX:CICompilerCount=4 -XX:InitialHeapSize=629145600 -XX:MaxHeapSize=629145600 -XX:MaxNewSize=209715200 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=209715200 -XX:OldSize=419430400 -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
```

> 会发现不管是输出的堆的大小都是575M，比设置的600M少了25M，这是因为两个Survivor区只使用一个，在计算的时候，另一个不参与计算。



## OOM示例

### 代码

```java

/**
 * -Xms600m -Xmx600m
 * @author shkstart  shkstart@126.com
 * @create 2020  21:12
 */
public class OOMTest {
    public static void main(String[] args) {
        ArrayList<Picture> list = new ArrayList<>();
        while(true){
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            list.add(new Picture(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Picture{
    private byte[] pixels;

    public Picture(int length) {
        this.pixels = new byte[length];
    }
}
```

### 正常结果

```java
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at com.chaocode.jvm.atguigu.chapter08.java.Picture.<init>(OOMTest.java:29)
	at com.chaocode.jvm.atguigu.chapter08.java.OOMTest.main(OOMTest.java:20)
```



### 使用 JVisualVM 工具查看

![image-20210120134117942](https://gitee.com/clancy/images/raw/master/img/image-20210120134117942.png)



![image-20210120134205050](https://gitee.com/clancy/images/raw/master/img/image-20210120134205050.png)



# 3- 年轻代与老年代

## 概念

### 对象分类

- 存储在JVM中的Java对象可以被划分为两类	
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。

### 堆内存划分

- Java堆区进一步细分的话，可以划分为年轻代( YoungGen)和老年代(OldGen)
- 其中年轻代又可以划分为Eden空间、 Survivor0空间和 Survivor1空间(有时也叫做from区、to区)。

![image-20210120135421824](https://gitee.com/clancy/images/raw/master/img/image-20210120135421824.png)

## 堆内存的分配比例

下面参数在开发中一般不会调

![image-20210120135843122](https://gitee.com/clancy/images/raw/master/img/image-20210120135843122.png)

- 配置新生代与老年代在堆结构的占比。
  - 默认`-XX:NewRatio=2`，表示新生代占1，老年代占2，新生代占整个堆的1/3
  - 可以修改`-XX:NewRatio=4`，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 新生代的结构占比
  - 默认 Eden区: Survivor0: Survivor1 = 8:1:1
  - `-XX:SurvivorRatio=6` ：设置新生代中Eden区与Survivor区的比例为6:1:1。默认值是8

## 案例分析代码

```java
/**
 * -Xms600m -Xmx600m
 *
 * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.
 * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8
 * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）
 * -Xmn:设置新生代的空间的大小。 （一般不设置）
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  17:23
 */
public class EdenSurvivorTest {
    public static void main(String[] args) {
        System.out.println("我只是来打个酱油~");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 运行参数`-Xms600m -Xmx600m`

`jvisualvm`查看占比

![image-20210120205621286](https://gitee.com/clancy/images/raw/master/img/20210120205631.png)

> 新生代与老年代比为：1 : 2

> Eden、S0、S1比为：7.5 : 1.25 : 1.25

### 运行参数`-Xms600m -Xmx600m -XX:NewRatio=1`

![image-20210120211455479](https://gitee.com/clancy/images/raw/master/img/20210120211503.png)

> 新生代与老年代的比值就变成 1 : 1

#### Command 查看

```java
C:\Users\Qiongchao>jps
4464 EdenSurvivorTest
13108
14740 Launcher
19828 Jps
5844 Main
16472 org.eclipse.equinox.launcher_1.6.0.v20200915-1508.jar
3260 KotlinCompileDaemon

C:\Users\Qiongchao>jinfo -flag NewRatio 4464
-XX:NewRatio=1

C:\Users\Qiongchao>jinfo -flag SurvivorRatio 4464
-XX:SurvivorRatio=8
```

## 新生代分配比

### 概念

在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1
当然开发人员可以通过选项`-XX:SurvivorRatio`调整这个空间比例。比如`-XX:SurvivorRatio=8`
**几乎所有**的Java对象都是在Eden区被new出来的。
绝大部分的Java对象的销毁都在新生代进行了。
IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
可以使用选项`-Xmn`设置新生代最大内存大小，这个参数一般使用默认值就可以了。

### 代码示例结果

#### 运行参数`-Xms600m -Xmx600m -XX:SurvivorRatio=8`

仔细看会发现新第生代的比例不是默认的 8:1:1，为什么新生代的比值不对那？因为JVM会根据情况微调比例。默认开启了`UseAdaptiveSizePolicy`自适应的内存分配策略。

`-XX:-UseAdaptiveSizePolicy` ：关闭自适应的内存分配策略 （暂时用不到）。自适应关闭也没有效果。如果强制某个比例需要使用`-XX:SurvivorRatio`来指定比例。如：`-XX:SurvivorRatio=8`指定新生代中Eden区与Survivor的比例为 8:1:1

![image-20210120211056633](https://gitee.com/clancy/images/raw/master/img/20210120211058.png)

> 新生代的Eden、S0、S1比就变成了 8 : 1 : 1

## 设置新生代的大小

> Eden过小会导致频繁的minorGC；survivor过小，会导致许多对象的GC次数不到15就到老年代了，那样survivor的作用就没有了，minorGC就没有意思了。

### JVM参数 `-Xms600m -Xmx600m -Xmn100m`

```java
C:\Users\Qiongchao>jps
12128 EdenSurvivorTest
20816 Jps
9360 Launcher
13108
5844 Main
16472 org.eclipse.equinox.launcher_1.6.0.v20200915-1508.jar
3260 KotlinCompileDaemon

C:\Users\Qiongchao>
C:\Users\Qiongchao>
C:\Users\Qiongchao>jinfo -flags 12128
VM Flags:
-XX:CICompilerCount=4 -XX:InitialHeapSize=629145600 -XX:MaxHeapSize=629145600 -XX:MaxNewSize=104857600 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=104857600 -XX:OldSize=524288000 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
```

JVM参数 `-Xms600m -Xmx600m -Xmn100m -XX:NewRatio=1`

同时设置`-Xmn10m`（新生代大小为10m）和设置`-XX:NewRatio=1`（指定新生代与老年代的比例 1:1）时，会忽略`-XX:NewRatio`的配置。

```shell
C:\Users\Qiongchao>jps
13108
5844 Main
15480 Jps
16472 org.eclipse.equinox.launcher_1.6.0.v20200915-1508.jar
10204 EdenSurvivorTest
18140 Launcher
3260 KotlinCompileDaemon

C:\Users\Qiongchao>jinfo -flags 10204
VM Flags:
-XX:CICompilerCount=4 -XX:InitialHeapSize=629145600 -XX:MaxHeapSize=629145600 -XX:MaxNewSize=104857600 -XX:MinHeapDeltaBytes=524288 -XX:NewRatio=1 -XX:NewSize=104857600 -XX:OldSize=524288000 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
```



## 对象晋升规则

- 当对象在Eden区，发生一次GC后，Eden区中，垃圾对象会被回收，存活的对象会被移到Survivor的To区。Eden每次GC会被清空。
- 每次GC也会把Survivor的From区的对象移动到To区，同时互换名称。To区总是空的。
- 当对象GC 15次还没有被回收的，就会被移到Old区（老年代）。只有Major GC或Full GC的时候才会检查收回Old区的对象。

![image-20210120213657722](https://gitee.com/clancy/images/raw/master/img/20210120213659.png)



# 4- 图解对象分配过程

## 概述

为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片

1. new的对象先放伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建对象，JM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被
3. 其他象所引用的对象进行销毁。再加载新的对象放到伊甸园区
4. 然后将伊甸园中的剩余对象移动到幸存者0区
5. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
6. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
7. 啥时候能去养老区呢？可以设置次数。默认是15次。
   
- 可以设置参数：`-XX:MaxTenuringThreshold=<N>`进行设置。
  
8. 在养老区，相对悠闲。当养老区内存不足时，再次触发GC: Major GC，进行养老区的内存清理。

9. 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常

   `java.lang.OutOfMemoryError:  Java heap space`

## GC图解

### 新生代图解

Eden区GC后，存活的对象会复制到Suvivor区。

S0区与S1区会有一个空着，每次Survivor区都会把From区的复制到To区，然后From区变To区，To区永远是空的。

![image-20210123205603659](https://gitee.com/clancy/images/raw/master/img/20210123205701.png)

### 整堆图解

Survivor区的对象回收15次（默认）后，还没有回收，就会移到老年代。

可通过`-XX:MaxTenuringThreshold=<N>`进行设置Survivor区对象的回收次数。

![image-20210123210633222](https://gitee.com/clancy/images/raw/master/img/20210123210635.png)



## GC图解示例

- Eden园区第一次GC后存活的对象，复制到S0区。
- Eden园区第二次GC后存活的对象复制到S1区，同时S0区GC后存活下来的对象会复制到S1区。
- 当Survivor区的对象GC 15次还没有被回收的，会复制到老年代。

![image-20210123210136644](https://gitee.com/clancy/images/raw/master/img/20210123210138.png)

## 总结

- 针对幸存者S0，S1的总结：复制之后有交换，谁空谁是to

- 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。



## 特殊情况的晋级

当年轻代的放不下的时候，对象会直接晋级到年老代。

![image-20210123212526039](https://gitee.com/clancy/images/raw/master/img/20210123212528.png)

### 示例代码

```java
/**
 * -Xms600m -Xmx600m
 * @author shkstart  shkstart@126.com
 * @create 2020  17:51
 */
public class HeapInstanceTest {
    byte[] buffer = new byte[new Random().nextInt(1024 * 200)];

    public static void main(String[] args) {
        ArrayList<HeapInstanceTest> list = new ArrayList<HeapInstanceTest>();
        while (true) {
            list.add(new HeapInstanceTest());
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```



![image-20210123220849618](https://gitee.com/clancy/images/raw/master/img/20210123220851.png)



## 常用调优工具

- JDK命令行
- Eclipse：Memory Analyzer Tool
- Jconsole
- VisualVM
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy

### Jprofiler安装使用

- 安装Jprofiler软件，安装中选择IDE。
- 在IDEA中安装Jprofiler插件。
- 在IDEA启动程序后，在工具栏中打开Jprofiler即可查看内存等情况。



# 5- Minor GC、Major GC、Full GC

## 概念

JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。
针对 Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集(Full GC)

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
  - 新生代收集（Minor GC / Young GC）：只是新生代（Eden\Sθ，S1）的垃圾收集
  - 老年代收集（Major GC / old GC）：只是老年代的垃圾收集。
    - 目前，只有 CMS GC会有单独收集老年代的行为。
    - 注意，很多时候 Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
- 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。
  - 目前，只有G1 GC会有这种行为
- 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。

## 最简单的分代式GC策略的触发条件

### 年轻代GC（Minor GC）触发机制：

- 当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是Eden代满， Survivor满不会引发GC。（每次 Minor GC会清理年轻代的内存。）
- 每次GC会清空一次。未回收的放到survivor的to区。同时会把survivor的from区的对象复制到to区（复制算法），from变to区，to区变from区。（to区永远为空）
- 因为Java对象大多都具备朝生夕灭的特性，所以 Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
- Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

### 老年代GC（Major GC/Full GC）触发机制:

- 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或”Full GC“发生了
- 出现了Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行 MaJor GC的策略选择过程)
  - 也就是在老年代空间不足时，会先尝试触发 Minor gc。如果之后空间还不足，则触发 MaJor GC
- Major GC的速度一般会比 Minor GC慢10倍以上，STW的时间更长。
- 如果 Major GC后，内存还不足，就报OOM了。
- Major GC的速度一般会比 Minor GC慢10倍以上。

### Full GC触发机制：（后面细讲）

触发Full GC执行的情况有如下五种：

1. 调用 System.gc()时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor space0（From Space）区向 survivor space1（To Space）区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

说明：**Full GC是开发或调优中尽量要避免的。这样暂时时间会短一些。**

### 对象晋升图

![image-20210125104113132](https://gitee.com/clancy/images/raw/master/img/image-20210125104113132.png)

### GC示例

#### 代码

```java
/**
 * 测试MinorGC 、 MajorGC、FullGC
 * -Xms9m -Xmx9m -XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  14:19
 */
public class GCTest {
    public static void main(String[] args) {
        int i = 0;
        try {
            List<String> list = new ArrayList<>();
            String a = "atguigu.com";
            while (true) {
                list.add(a);
                a = a + a;
                i++;
            }

        } catch (Throwable t) {
            t.printStackTrace();
            System.out.println("遍历次数为：" + i);
        }
    }
}
```

#### GC结果

```shell
[GC (Allocation Failure) [PSYoungGen: 2048K->504K(2560K)] 2048K->902K(9728K), 0.0042521 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2465K->504K(2560K)] 2864K->1729K(9728K), 0.0014011 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 1973K->504K(2560K)] 3198K->2825K(9728K), 0.0012059 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 1982K->0K(2560K)] [ParOldGen: 6545K->5150K(7168K)] 8527K->5150K(9728K), [Metaspace: 3293K->3293K(1056768K)], 0.0107441 secs] [Times: user=0.05 sys=0.02, real=0.01 secs] 
[GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] 5150K->5150K(9728K), 0.0004678 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] [ParOldGen: 5150K->5132K(7168K)] 5150K->5132K(9728K), [Metaspace: 3293K->3293K(1056768K)], 0.0106406 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOf(Arrays.java:3332)
	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)
	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)
	at java.lang.StringBuilder.append(StringBuilder.java:136)
	at com.chaocode.jvm.atguigu.chapter08.java1.GCTest.main(GCTest.java:20)
遍历次数为：16
Heap
 PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f238,0x00000000fff00000)
  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
 ParOldGen       total 7168K, used 5132K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
  object space 7168K, 71% used [0x00000000ff600000,0x00000000ffb032c0,0x00000000ffd00000)
 Metaspace       used 3324K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 362K, capacity 388K, committed 512K, reserved 1048576K
```





# 6- 堆空间分代思想

## 为什么分代

为什么需要把Java堆分代?不分代就不能正常工作了吗?

- 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。
  - 新生代：有Eden、两块大小相同的 Survivor（又称为from/to，s0/s1）构成，to总为空。
  - 老年代:存放新生代中经历多次Gc仍然存活的对象。

![image-20210125122657513](https://gitee.com/clancy/images/raw/master/img/image-20210125122657513.png)

- 其实不分代完全可以，分代的唯一理由就是**优化GC性能**。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当G的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。

![image-20210125124203339](https://gitee.com/clancy/images/raw/master/img/image-20210125124203339.png)





# 7- 内存分配策略（或对象提升(promotion)规则）

如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被 Survivor容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。

对象晋升老年代的年龄阈值，可以通过选项`-XX:MaxTenuringThreshold`来设置。

针对不同年龄段的对象分配原则如下所示：

- 优先分配到Eden
- 大对象直接分配到老年代
  - 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  - 如果 Survivor区中相同年龄的所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
- 空间分配担保
  - `-XX:HandlepromotionFailure`

## 实践

### 代码

```java
/** 测试：大对象直接进入老年代
 * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  21:48
 */
public class YoungOldAreaTest {
    public static void main(String[] args) {
        byte[] buffer = new byte[1024 * 1024 * 20];//20m

    }
}
```

### 结果

结果显示只有老年代使用了20480K，就是New的对象。

```shell
Heap
 PSYoungGen      total 18432K, used 3294K [0x00000000fec00000, 0x0000000100000000, 0x0000000100000000)
  eden space 16384K, 20% used [0x00000000fec00000,0x00000000fef37918,0x00000000ffc00000)
  from space 2048K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x0000000100000000)
  to   space 2048K, 0% used [0x00000000ffc00000,0x00000000ffc00000,0x00000000ffe00000)
 ParOldGen       total 40960K, used 20480K [0x00000000fc400000, 0x00000000fec00000, 0x00000000fec00000)
  object space 40960K, 50% used [0x00000000fc400000,0x00000000fd800010,0x00000000fec00000)
 Metaspace       used 3298K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 359K, capacity 388K, committed 512K, reserved 1048576K
```



# 8- 为对象分配内存：TLAB

## 为什么有TLAB（Thread Local Allocation Buffer）?

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

## 什么是TLAB？

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。
- 据我所知所有openJDK衍生出来的JVM都提供了TLAB的设计。

## TLAB图解

![image-20210125130614337](https://gitee.com/clancy/images/raw/master/img/image-20210125130614337.png)

## TLAB再说明

- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**。
- 在程序中，开发人员可以通过选项`-XX:UseTLAB`设置是否开启TLAB空间。
- 默认情况下，TLAB空间的内存非常小，**仅占有整个Eden空间的1%**，当然我们可以通过选项`-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden空间的百分比大小。
- 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制**确保数据操作的原子性，从而直接在Eden空间中分配内存。

## 实践-验证`-XX:UseTLAB`

### 代码

```java
/**
 * 测试-XX:UseTLAB参数是否开启的情况:默认情况是开启的
 * 查看方式
 *  - jps
 *      查看程序的进程id
 *  - jinfo -flag UseTLAB 进程id
 *      打印UseTLAB是否开启
 *
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  16:16
 */
public class TLABArgsTest {
    public static void main(String[] args) {
        System.out.println("我只是来打个酱油~");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 启动后结果

```shell
C:\Users\QiongchaoLi>jps
27328
11512 Launcher
29672 Jps
17580 Launcher
22156 TLABArgsTest
28028 org.eclipse.equinox.launcher_1.6.0.v20200915-1508.jar
7516 Main

C:\Users\QiongchaoLi>jinfo -flag UseTLAB 22156
-XX:+UseTLAB
```

### 结论

TLAB功能默认开启。

## TLAB分配过程图解

![image-20210125132310966](https://gitee.com/clancy/images/raw/master/img/image-20210125132310966.png)



# 9- 小结堆空间的参数设置

## 堆空间的参数设置

官网：[https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC)

- -XX:+PrintFlagsInitial：查看所有的参数的默认初始值
- -XX:+PrintFlagsFinal：査看所有的参数的最终值（可能会存在修改，不再是初始值）
- -Xms：初始堆空间内存（默认为物理内存的1/64）
- -Xmx：最大堆空间内存（默认为物理内存的1/4）
- -Xmn：设置新生代的大小。（初始值及最大值）
- -XX:NewRatio：配置新生代与老年代在堆结构的占比

- -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例
- -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄
- -XX:+PrintGCDetails：输出详细的GC处理日志
  - 打印GC简要信息：① -XX:+PrintGC ② -verbose:gc
- -XX:HandlePromotionFailure：是否设置空间分配担保

## 实践

### `-XX:+PrintFlagsFinal`测试

#### 代码

```java
/**
 * 测试堆空间常用的jvm参数：
 * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值
 * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）
 *      具体查看某个参数的指令： jps：查看当前运行中的进程
 *                             jinfo -flag SurvivorRatio 进程id
 *
 * -Xms：初始堆空间内存 （默认为物理内存的1/64）
 * -Xmx：最大堆空间内存（默认为物理内存的1/4）
 * -Xmn：设置新生代的大小。(初始值及最大值)
 * -XX:NewRatio：配置新生代与老年代在堆结构的占比
 * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例
 * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄
 * -XX:+PrintGCDetails：输出详细的GC处理日志
 * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc
 * -XX:HandlePromotionFailure：是否设置空间分配担保
 *
 * @author shkstart  shkstart@126.com
 * @create 2020  17:18
 */
public class HeapArgsTest {
    public static void main(String[] args) {

    }
}
```

#### 参数：`-XX:+PrintFlagsFinal -XX:SurvivorRatio=5`结果

> `:=` 开头的值，表示为修改过的值。

```shell
    ……
    uintx StringDeduplicationAgeThreshold           = 3                                   {product}
    uintx StringTableSize                           = 60013                               {product}
     bool SuppressFatalErrorMessage                 = false                               {product}
    uintx SurvivorPadding                           = 3                                   {product}
    uintx SurvivorRatio                            := 5                                   {product}
     intx SuspendRetryCount                         = 50                                  {product}
     intx SuspendRetryDelay                         = 5                                   {product}
     intx SyncFlags                                 = 0                                   {product}
     ……
```

### GCTest测试

> 代码参照***5- Minor GC、Major GC、Full GC***里的`GCTest.java`，

#### `-Xms100m -Xmx100m -XX:+PrintGCDetails`结果

```java
[GC (Allocation Failure) [PSYoungGen: 20356K->4069K(29696K)] 20356K->12349K(98304K), 0.0060666 secs] [Times: user=0.03 sys=0.03, real=0.01 secs] 
[GC (Allocation Failure) [PSYoungGen: 21458K->1100K(29696K)] 29738K->26284K(98304K), 0.0049243 secs] [Times: user=0.05 sys=0.03, real=0.01 secs] 
[GC (Allocation Failure) [PSYoungGen: 24638K->1122K(29696K)] 49822K->37570K(98304K), 0.0070274 secs] [Times: user=0.09 sys=0.00, real=0.01 secs] 
[Full GC (Ergonomics) [PSYoungGen: 12881K->0K(29696K)] [ParOldGen: 58976K->45865K(68608K)] 71857K->45865K(98304K), [Metaspace: 3296K->3296K(1056768K)], 0.0144061 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 
[Full GC (Ergonomics) [PSYoungGen: 23023K->0K(29696K)] [ParOldGen: 68393K->68393K(68608K)] 91416K->68393K(98304K), [Metaspace: 3296K->3296K(1056768K)], 0.0101230 secs] [Times: user=0.13 sys=0.00, real=0.01 secs] 
[GC (Allocation Failure) [PSYoungGen: 0K->0K(29696K)] 68393K->68393K(98304K), 0.0005488 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(29696K)] [ParOldGen: 68393K->68375K(68608K)] 68393K->68375K(98304K), [Metaspace: 3296K->3296K(1056768K)], 0.0157213 secs] [Times: user=0.09 sys=0.00, real=0.02 secs] 
java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOf(Arrays.java:3332)
	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)
	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)
	at java.lang.StringBuilder.append(StringBuilder.java:136)
	at com.chaocode.jvm.atguigu.chapter08.java1.GCTest.main(GCTest.java:20)
遍历次数为：20
Heap
 PSYoungGen      total 29696K, used 1013K [0x00000000fdf00000, 0x0000000100000000, 0x0000000100000000)
  eden space 25600K, 3% used [0x00000000fdf00000,0x00000000fdffd5e0,0x00000000ff800000)
  from space 4096K, 0% used [0x00000000ffc00000,0x00000000ffc00000,0x0000000100000000)
  to   space 4096K, 0% used [0x00000000ff800000,0x00000000ff800000,0x00000000ffc00000)
 ParOldGen       total 68608K, used 68375K [0x00000000f9c00000, 0x00000000fdf00000, 0x00000000fdf00000)
  object space 68608K, 99% used [0x00000000f9c00000,0x00000000fdec5e48,0x00000000fdf00000)
 Metaspace       used 3328K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 362K, capacity 388K, committed 512K, reserved 1048576K
```

#### `-Xms100m -Xmx100m -XX:+PrintGC`结果

```shell
[GC (Allocation Failure)  20356K->12317K(98304K), 0.0038191 secs]
[GC (Allocation Failure)  29706K->26284K(98304K), 0.0060456 secs]
[GC (Allocation Failure)  49822K->37602K(98304K), 0.0068835 secs]
[Full GC (Ergonomics)  71889K->45865K(98304K), 0.0112062 secs]
[Full GC (Ergonomics)  91416K->68393K(98304K), 0.0112431 secs]
[GC (Allocation Failure)  68393K->68393K(98304K), 0.0005340 secs]
[Full GC (Allocation Failure)  68393K->68375K(98304K), 0.0151710 secs]
java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOf(Arrays.java:3332)
	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)
	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)
	at java.lang.StringBuilder.append(StringBuilder.java:136)
	at com.chaocode.jvm.atguigu.chapter08.java1.GCTest.main(GCTest.java:20)
遍历次数为：20
```



## HandlePromotionFailure（手动担保失败）

在发生 Minor GC之前，虚拟机会**检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**。

- 如果大于，则此次 Minor GC是安全的
- 如果小于，则虚拟机会查看`-XX:HandlePromotionFailure`设置值是否允许担保失败。
  - 如果`HandlePromotionFailure=true`，那么会继续**检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**。
    - 如果大于，则尝试进行一次 Minor GC，但这次Minor GC依然是有风险的；
    - 如果小于，则改为进行一次Full GC。
- 如果`HandlePromotionFailure=false`，则改为进行一次Full GC。
- 在JDK6 Update24之后， HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为**只要老年代的连续空间大于新生代对象总大小**或者**历次晋升的平均大小就会进行Minor GC**，否则将进行Full GC。



# 10- 堆是分配对象的唯一选择吗

在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：

随着JIT编译期的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换优化技术**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有种特殊情况，那就是**如果经过逃逸分析( Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

此外，前面提到的基于OpenJDk深度定制的 TaoBao，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。

## 逃逸分析概述

> Oracle JDK默认未使用逃逸分析。Oracle JDK8 Server版默认开启。
>
> [官网说明](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC)
>
> `-XX:+DoEscapeAnalysis`
>
> Enables the use of escape analysis. This option is enabled by default. To disable the use of escape analysis, specify `-XX:-DoEscapeAnalysis`. Only the Java HotSpot Server VM supports this option.

- 如何将堆上的对象分配到栈，需要使用逃逸分析手段
- 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
- 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

- 逃逸分析的基本行为就是分析对象动态作用域：
  - 当一个对象在方法中被定义后，**对象只在方法内部使用，则认为没有发生逃逸。**
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

### 未逃逸现象

```java
public void myMethod(){
	V v = new V();
    // use v
    v = null;
}
```

没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。

### 逃逸优化

优化前-逃逸

```java
public static StringBuffer createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
}
```

优化后-未逃逸

```java
public static String createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
}
```

### 逃逸案例分析

```java
/**
 * 逃逸分析
 *
 *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。
 * @author shkstart
 * @create 2020 下午 4:00
 */
public class EscapeAnalysis {

    public EscapeAnalysis obj;

    /*
    方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance(){
        return obj == null? new EscapeAnalysis() : obj;
    }
    /*
    为成员属性赋值，发生逃逸
     */
    public void setObj(){
        this.obj = new EscapeAnalysis();
    }
    //思考：如果当前的obj引用声明为static的？仍然会发生逃逸。

    /*
    对象的作用域仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis(){
        EscapeAnalysis e = new EscapeAnalysis();
    }
    /*
    引用成员变量的值，发生逃逸
     */
    public void useEscapeAnalysis1(){
        EscapeAnalysis e = getInstance();
        //getInstance().xxx()同样会发生逃逸
    }
}
```

### 逃逸参数设置

- 在JDK 6u23版本之后， Hotspot中默认就已经开启了逃逸分析。
- 如果使用的是较早的版本，开发人员则可以通过：
  - 选项`-XX:+DoEscapeAnalysis`显式开启逃逸分析
  - 通过选项`-XX:+PrintEscapeAnalysis`査看逃逸分析的筛选结果。

### 结论

开发中能使用局部变量的，就不要使用在方法外定义。

## 逃逸分析：代码优化

使用逃逸分析，编译器可以对代码做如下优化：

**一、栈上分配。**将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

**二、同步省略。**如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

**三、分离对象或标量替换。**有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

## 代码优化之栈上分配

- JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。
- 常见的栈上分配的场景
  - 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。



### 逃逸分析实践

#### 代码

```java
/**
 * 栈上分配测试
 * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
 * @author shkstart  shkstart@126.com
 * @create 2020  10:31
 */
public class StackAllocation {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 10000000; i++) {
            alloc();
        }
        // 查看执行时间
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为： " + (end - start) + " ms");
        // 为了方便查看堆内存中对象个数，线程sleep
        try {
            // Thread.sleep(1000000);
            Thread.sleep(10000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
    }

    private static void alloc() {
        User user = new User();//未发生逃逸
    }

    static class User {

    }
}
```

#### 关闭逃逸分析结果

参数

`-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails`

#### 控制台输出结果

```shell
花费的时间为： 89 ms
Heap
 PSYoungGen      total 305664K, used 183501K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 262144K, 70% used [0x00000000eab00000,0x00000000f5e33620,0x00000000fab00000)
  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)
  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)
 ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)
  object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)
 Metaspace       used 3810K, capacity 4540K, committed 4864K, reserved 1056768K
  class space    used 420K, capacity 428K, committed 512K, reserved 1048576K
```

#### JVisualVM显示

![image-20210126130714052](https://gitee.com/clancy/images/raw/master/img/image-20210126130714052.png)

#### 开启逃逸分析【Server版默认】

参数

`-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails`

#### 控制台输出

```shell
花费的时间为： 5 ms
Heap
 PSYoungGen      total 305664K, used 26214K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 262144K, 10% used [0x00000000eab00000,0x00000000ec499b50,0x00000000fab00000)
  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)
  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)
 ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)
  object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)
 Metaspace       used 3811K, capacity 4540K, committed 4864K, reserved 1056768K
  class space    used 420K, capacity 428K, committed 512K, reserved 1048576K
```

#### JVisualVM显示

![image-20210126131210853](https://gitee.com/clancy/images/raw/master/img/image-20210126131210853.png)



## 代码优化之同步省略（消除）

### 概念

- 线程同步的代价是相当高的，同步的后果是降低并发性和性能。
- 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来**判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程**。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫**锁消除**。

### 代码示例

#### 优化前代码

```java
public void f() {
	Object hollis = new Object();
	synchronized(hollis) {
		System.out.println(hollis);
	}
}
```

#### 优化前的字节码

```shell
 0 new #2 <java/lang/Object>
 3 dup
 4 invokespecial #1 <java/lang/Object.<init>>
 7 astore_1
 8 aload_1
 9 dup
10 astore_2
11 monitorenter
12 getstatic #3 <java/lang/System.out>
15 aload_1
16 invokevirtual #4 <java/io/PrintStream.println>
19 aload_2
20 monitorexit
21 goto 29 (+8)
24 astore_3
25 aload_2
26 monitorexit
27 aload_3
28 athrow
29 return
```

> 11行与20行分别是加锁和去锁。

代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。

#### 优化后

```java
public void f() {
	Object hollis = new Object();
    System.out.println(hollis);
}
```



## 代码优化之标量替换【默认打开】

### 概念

**标量（Scalax）**是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。

相对的，那些还可以分解的数据叫做**聚合量（Aggregate）**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话（未逃逸），那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是**标量替换**。（栈上分配基于此实现）

### 代码示例

#### 标题替换前代码

```java
    public static void main(String[] args) {
        alloc();
    }

    private static void alloc() {
        Point point = new Point();
        System.out.println("point.x=" + point.x + "; point.y=" + point.y);
    }

    class Point {
        private int x;
        private int y;
    }
```

#### 标量替换的代码

```java
private static void alloc() {
        int x = 0;
        int y = 0;
        System.out.println("point.x=" + x + "; point.y=" + y);
    }
```

可以看到， Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢?就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。

标量替换为栈上分配提供了很好的基础。

### 标量替换参数设置

参数`-XX:+EliminateAllocations`开启了标量替换(默认打开)，允许将对象打散分配在栈上。

### 代码实践

#### 代码

```java
/**
 * 标量替换测试
 *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations
 * @author shkstart  shkstart@126.com
 * @create 2020  12:01
 */
public class ScalarReplace {
    public static class User {
        public int id;
        public String name;
    }

    public static void alloc() {
        User u = new User();//未发生逃逸
        u.id = 5;
        u.name = "www.atguigu.com";
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000000; i++) {
            alloc();
        }
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为： " + (end - start) + " ms");
    }
}

/*
class Customer{
    String name;
    int id;
    Account acct;

}

class Account{
    double balance;
}

 */
```

#### 开启逃逸，不开启标量替换

JVM参数：`-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations`

```shell
[GC (Allocation Failure)  25600K->1059K(98304K), 0.0015099 secs]
[GC (Allocation Failure)  26659K->968K(98304K), 0.0010453 secs]
[GC (Allocation Failure)  26568K->1008K(98304K), 0.0008499 secs]
[GC (Allocation Failure)  26608K->960K(98304K), 0.0011754 secs]
[GC (Allocation Failure)  26560K->944K(98304K), 0.0012850 secs]
[GC (Allocation Failure)  26544K->912K(100864K), 0.0019680 secs]
[GC (Allocation Failure)  31632K->877K(100864K), 0.0008359 secs]
[GC (Allocation Failure)  31597K->877K(100864K), 0.0004635 secs]
花费的时间为： 83 ms
```

#### 开启标量替换

JVM参数：`-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations`

```java
花费的时间为： 6 ms
```

上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码:

```shell
-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:EliminateAllocations
```

这里使用参数如下：

- 参数`-server`：启动Server模式，因为在Server模式下，才可以启用逃逸分析。
- 参数`-XX:+DoEscapeAnalysis`：启用逃逸分析
- 参数`-Xmx10m`：指定了堆空间最大为10MB
- 参数`-XX:+Prints`：将打印Gc日志。
- 参数`-XX:+EliminateAllocations`：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配。

## 逃逸分析小结：逃逸分析并不成熟

- 关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。
- 其根本原因就是**无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。**
- 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
- 虽然这项技术并不十分成熟，但是它也**是即时编译器优化技术中一个十分重要的手段**。
- 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，**所以可以明确所有的对象实例都是创建在堆上**。
- 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化， intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。

- 年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。
- 老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。
- 当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。一般的， MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。



## 对象是都分配在堆空间上吗？（要看使用场景）

如果他用的逃逸分析，会分配到栈上。

如果使用标量替换，则会把对象聚合量拆一个个的标量（基本数据类型），定义在栈上。



# 总结

client(C1)方法内联、去虚拟化、冗余消除
Server(C2)逃逸分析、标量替换、栈上分配、同步消除。




